@App:name("PStr_-_Secound_Project")

--SOURCES

@source( type='kafka',
         topic.list='debs',
         partition.no.list='0',
         threading.option='single.thread',
         group.id="group",
         bootstrap.servers='localhost:9092',
         @map(type='csv') )
--@info(name = 'input stream') 
define stream TaxiRidesProductionStream (medallion string, hack_license string, pickup_datetime string, dropoff_datetime string, trip_time_in_secs double, trip_distance double, pickup_longitude double, pickup_latitude double, dropoff_longitude double, dropoff_latitude double, payment_type string, fare_amount double, surcharge double, mta_tax double, tip_amount double, tolls_amount double, total_amount double);

--SINKS

/*
@sink(type='log')
define stream TestKafkaStr (medallion string);
*/

--@sink(type='log', prefix='Frequent Routes')
define stream TopFreqRoutesStr(pickup_gridID string, dropoff_gridID string, frequency long);

--@sink(type='log', prefix='Profitable Areas')
define stream ProfitPerAreaStr(areaID string, profit double);

--@sink(type='log', prefix='Idle Taxi')
define stream IdleTaxisStr (avg_idle_time double);

--@sink(type='log', prefix='Congested Areas')
define stream CongestedAreasStr (areaID string);

@sink(type='log', prefix= 'Pleasant Driver') 
define stream PleasantDriverStr (medallion string, tips_total double);

--Auxiliary Streams

define stream AvailableTaxisStr (medallion string, hack_license string, pickup_gridID string, dropoff_gridID string, ride_duration long, tip_amount double, pickup_datetime string, dropoff_datetime string);

--@sink(type='log', prefix='input') 
define stream TaxiSecStr (medallion string, hack_license string, pickup_gridID string, dropoff_gridID string, ride_duration long, fare_amount double, tip_amount double, pickup_datetime string, dropoff_datetime string);

define stream EmptyTaxisAreasStr(areaID string);

define stream RevenuePerAreaStr(areaID string, revenue double);

define stream IdleTimeTaxisStr (idle_time long);

define stream RouteFrequencyStr (pickup_gridID string, dropoff_gridID string, frequency long);

--@sink(type='log', prefix= 'Today Tips per Driver') 
define stream TodayDriversTips (medallion string, tips_total double);

--QUERIES

/*
--Testing Kafka
from TaxiRidesProductionStream
select medallion
insert into TestKafkaStr;
*/

-- Transform longitude and latitude to grid cells, and adds the ride_duration in seconds
@info(name = 'transform coordinates to sectors')
from TaxiRidesProductionStream[pickup_longitude != 0 and pickup_latitude != 0 and dropoff_longitude != 0 and dropoff_latitude != 0]
select medallion, hack_license, str:concat(math:floor(math:abs(-74.913585 - pickup_longitude) / 0.0059986), ';', math:floor(math:abs(41.474937 - pickup_latitude) / 0.004491556)) as pickup_gridID, str:concat(math:floor(math:abs(-74.913585 - dropoff_longitude) / 0.0059986), ';',math:floor(math:abs(41.474937 - dropoff_latitude) / 0.004491556)) as dropoff_gridID, (time:timestampInMilliseconds(dropoff_datetime, 'yyyy-MM-dd HH:mm:ss') - time:timestampInMilliseconds(pickup_datetime, 'yyyy-MM-dd HH:mm:ss'))/1000 as ride_duration, fare_amount, tip_amount, pickup_datetime, dropoff_datetime
insert into TaxiSecStr;


--Frequent Routes

from TaxiSecStr#window.time(30 minutes)
select pickup_gridID, dropoff_gridID, count(*) as frequency
group by pickup_gridID, dropoff_gridID
order by frequency DESC
insert into RouteFrequencyStr;

from RouteFrequencyStr#window.length(10)
select *
insert into TopFreqRoutesStr;

--Profitables Areas
/* 
Profitability is defined as the median fare plus the
tip for last 15 minutes divided by the number of taxi drivers
who have dropped-off and have not taken a new trip in the
last 30 minutes
*/

from e1 = TaxiSecStr
		-> TaxiSecStr[medallion == e1.medallion and (time:timestampInMilliseconds(pickup_datetime, 'yyyy-MM-dd HH:mm:ss') - time:timestampInMilliseconds(e1.dropoff_datetime, 'yyyy-MM-dd HH:mm:ss'))/1000 > 30 * 60 ]
select e1.dropoff_gridID as areaID
insert into EmptyTaxisAreasStr; 

from TaxiSecStr#window.time(15 min)
select pickup_gridID as areaID, avg(fare_amount + tip_amount) as revenue
group by pickup_gridID
insert into RevenuePerAreaStr;

partition with (areaID of ProfitPerAreaStr)
begin
    from EmptyTaxisAreasStr
    select areaID, count(*) as emptyTaxis
    insert into #EmptyTaxisPerAreaStr;

    from RevenuePerAreaStr as A join #EmptyTaxisPerAreaStr as B on A.areaID == B.areaID
    select A.areaID, revenue/emptyTaxis as profit
    insert into ProfitPerAreaStr;
end;

/*
To control possible periods of the day when the number of taxis available is too much, 
the city wants to b e alerted whenever the average idle time of taxis is greater than a 
given amount of time (say 10 minutes). 
The idle time of a taxi is the time mediating between the drop off of a ride, and the pickup time of the following ride. 
It is assumed that a taxi is available if it had at least one ride in the last hour.
*/

from TaxiSecStr#window.time(1 hour)
select medallion, hack_license, pickup_gridID, dropoff_gridID, ride_duration, tip_amount, pickup_datetime, dropoff_datetime
insert into AvailableTaxisStr;

from e1 = AvailableTaxisStr
        -> e2 = AvailableTaxisStr [medallion == e1.medallion]
select (time:timestampInMilliseconds(e2.pickup_datetime, 'yyyy-MM-dd HH:mm:ss') - time:timestampInMilliseconds(e1.dropoff_datetime, 'yyyy-MM-dd HH:mm:ss'))/1000  as idle_time
insert into IdleTimeTaxisStr;


-- idle_time is in seconds
from IdleTimeTaxisStr
select avg(idle_time) as avg_idle_time
having avg_idle_time > 10 * 60
insert into IdleTaxisStr;



/*
The city wants to know about the areas where, when the taxis enter there, the rides 
increase in their duration. For that, there should be alerts when a taxi has a peak in 
the duration of the ride that is followed by at least 3 rides all increasing in their 
duration. The alert should contain the location 
where the taxi started the ride which had the peak duration.
*/

from every e1 = TaxiSecStr ->
  e2 = TaxiSecStr[medallion == e1.medallion and ride_duration > e1.ride_duration] ->
  e3 = TaxiSecStr[medallion == e2.medallion and ride_duration < e2.ride_duration] ->
  e4 = TaxiSecStr[medallion == e3.medallion and ride_duration > e3.ride_duration] ->
  e5 = TaxiSecStr[medallion == e4.medallion and ride_duration > e4.ride_duration] ->
  e6 = TaxiSecStr[medallion == e5.medallion and ride_duration > e5.ride_duration]
select e2.pickup_gridID as areaID
insert into CongestedAreasStr;

/*
To distinguish the most pleasant taxi drivers, it should be nice to have an event, 
emitted once a day, signalling the taxi driver with the highest total amount of tips in that day
*/

from TaxiSecStr#window.timeBatch(1 min)
select medallion, sum(tip_amount) as tips_total
group by medallion
order by tips_total DESC
insert into TodayDriversTips;

from TodayDriversTips#window.length(1)
select *
insert into PleasantDriverStr;
