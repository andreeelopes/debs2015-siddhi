@App:name("PStr_-_Secound_Project")

--SOURCES

@info(name = 'input stream') 
define stream TaxiRidesProductionStream (medallion string, hack_license string, pickup_datetime string, dropoff_datetime string, trip_time_in_secs double, trip_distance double, pickup_longitude double, pickup_latitude double, dropoff_longitude double, dropoff_latitude double, payment_type string, fare_amount double, surcharge double, mta_tax double, tip_amount double, tolls_amount double, total_amount double);


--SINKS

@sink(type='log', prefix='Frequent Routes')
define stream TopFreqRoutesStr(pickup_grid_x double, pickup_grid_y double, dropoff_grid_x double, dropoff_grid_y double, frequency long);

--@sink(type='log', prefix='Idle Taxi')
define stream IdleTaxisStr (avg_idle_time double);


--@sink(type='log', prefix='Congested Areas')
define stream CongestedAreasStr (medallion string, grid_x double, grid_y double);


--@sink(type='log', prefix= 'Today Tips per Driver') 
define stream TodayDriversTips (medallion string, tips_total double);

--@sink(type='log', prefix= 'Pleasant Driver') 
define stream PleasantDriverStr (medallion string, tips_total double);

--Auxiliary Streams

define stream AvailableTaxisStr (medallion string, hack_license string, pickup_grid_x double, pickup_grid_y double, dropoff_grid_x double, dropoff_grid_y double, ride_duration long, tip_amount double, pickup_datetime string, dropoff_datetime string);
--@sink(type='log', prefix='input') 
define stream TaxiSecStr (medallion string, hack_license string, pickup_grid_x double, pickup_grid_y double, dropoff_grid_x double, dropoff_grid_y double, ride_duration long, fare_amount double, tip_amount double, pickup_datetime string, dropoff_datetime string);

define stream IdleTimeTaxisStr (idle_time long);

define stream EmptyGridsStr (pickup_grid_x double, pickup_grid_y double, dropoff_grid_x double, dropoff_grid_y double);

define stream RouteFrequencyStr (pickup_grid_x double, pickup_grid_y double, dropoff_grid_x double, dropoff_grid_y double, frequency long);

--QUERIES

-- Transform longitude and latitude to grid cells, and adds the ride_duration in seconds
@info(name = 'transform coordinates to sectors')
from TaxiRidesProductionStream[pickup_longitude != 0 and pickup_latitude != 0 and dropoff_longitude != 0 and dropoff_latitude != 0]
select medallion, hack_license, math:floor(math:abs(-74.913585 - pickup_longitude) / 0.0059986) as pickup_grid_x, math:floor(math:abs(41.474937 - pickup_latitude) / 0.004491556) as pickup_grid_y, math:floor(math:abs(-74.913585 - dropoff_longitude) / 0.0059986) as dropoff_grid_x, math:floor(math:abs(41.474937 - dropoff_latitude) / 0.004491556) as dropoff_grid_y, (time:timestampInMilliseconds(dropoff_datetime, 'yyyy-MM-dd HH:mm:ss') - time:timestampInMilliseconds(pickup_datetime, 'yyyy-MM-dd HH:mm:ss'))/1000 as ride_duration, fare_amount, tip_amount, pickup_datetime, dropoff_datetime
insert into TaxiSecStr;


--Frequent Routes

from TaxiSecStr#window.time(30 minutes)
select pickup_grid_x, pickup_grid_y, dropoff_grid_x, dropoff_grid_y, count(*) as frequency
group by pickup_grid_x, pickup_grid_y, dropoff_grid_x, dropoff_grid_y
order by frequency DESC
insert into RouteFrequencyStr;

from RouteFrequencyStr#window.length(10)
select *
insert into TopFreqRoutesStr;

--Profitables Areas
/* 
Profitability is defined as the median fare plus the
tip for last 15 minutes divided by the number of taxi drivers
who have dropped-off and have not taken a new trip in the
last 30 minutes
*/


from e1 = TaxiSecStr
		-> TaxiSecStr[e1.medallion == medallion and (time:timestampInMilliseconds(pickup_datetime, 'yyyy-MM-dd HH:mm:ss') - time:timestampInMilliseconds(e1.dropoff_datetime, 'yyyy-MM-dd HH:mm:ss'))/1000 > 30 * 60 ]
select pickup_grid_x, pickup_grid_y, dropoff_grid_x, dropoff_grid_y
insert into EmptyGridsStr; 

partition with (pickup_grid_x of EmptyGridsStr, pickup_grid_y of EmptyGridsStr, dropoff_grid_x of EmptyGridsStr, dropoff_grid_y of EmptyGridsStr)
begin
    from EmptyGridsStr
    select pickup_grid_x, pickup_grid_y, dropoff_grid_x, dropoff_grid_y, count(*) as emptyTaxis
    insert into #EmptyTaxisStr
    from TaxiSecStr#window.time(15 min)
    
    select pickup_grid_x, pickup_grid_y, dropoff_grid_x, dropoff_grid_y, avg(fare_amount + tip_amount) as profit
    group by pickup_grid_x, pickup_grid_y, dropoff_grid_x, dropoff_grid_y
    insert into #ProfitPerAreaStr
    
    from #ProfitPerAreaStr as A join #EmptyTaxisStr as B on (A.pickup_grid_x == B.pickup_grid_x AND A.pickup_grid_y == B.pickup_grid_y AND A.dropoff_grid_x == B.dropoff_grid_x AND A.dropoff_grid_y == B.dropoff_grid_y)
    select profit/emptyTaxis as GridProfit, A.pickup_grid_x, A.pickup_grid_y, A.dropoff_grid_x, A.dropoff_grid_y
    insert into resultadoFinalStr
end;
/*
To control possible periods of the day when the number of taxis available is too much, 
the city wants to b e alerted whenever the average idle time of taxis is greater than a 
given amount of time (say 10 minutes). 
The idle time of a taxi is the time mediating between the drop off of a ride, and the pickup time of the following ride. 
It is assumed that a taxi is available if it had at least one ride in the last hour.
*/
from TaxiSecStr#window.time(1 hour)
select medallion, hack_license, pickup_grid_x, pickup_grid_y, dropoff_grid_x, dropoff_grid_y, ride_duration, tip_amount, pickup_datetime, dropoff_datetime
insert into AvailableTaxisStr;

from e1 = AvailableTaxisStr
        -> e2 = AvailableTaxisStr [medallion == e1.medallion]
select (time:timestampInMilliseconds(e2.pickup_datetime, 'yyyy-MM-dd HH:mm:ss') - time:timestampInMilliseconds(e1.dropoff_datetime, 'yyyy-MM-dd HH:mm:ss'))/1000  as idle_time
insert into IdleTimeTaxisStr;


-- idle_time is in seconds
from IdleTimeTaxisStr
select avg(idle_time) as avg_idle_time
having avg_idle_time > 10 * 60
insert into IdleTaxisStr;



/*
The city wants to know about the areas where, when the taxis enter there, the rides 
increase in their duration. For that, there should be alerts when a taxi has a peak in 
the duration of the ride that is followed by at least 3 rides all increasing in their 
duration. The alert should contain the location 
where the taxi started the ride which had the peak duration.


from every e1 = TaxiSecStr ->
  e2 = TaxiSecStr[medallion == e1.medallion and ride_duration > e1.ride_duration] ->
  e3 = TaxiSecStr[medallion == e2.medallion and ride_duration < e2.ride_duration] ->
  e4 = TaxiSecStr[medallion == e3.medallion and ride_duration > e3.ride_duration] ->
  e5 = TaxiSecStr[medallion == e4.medallion and ride_duration > e4.ride_duration] ->
  e6 = TaxiSecStr[medallion == e5.medallion and ride_duration > e5.ride_duration]
select e2.pickup_grid_x as grid_x, e2.pickup_grid_y as grid_y
insert into CongestedAreasStr;
*/
/*
To distinguish the most pleasant taxi drivers, it should be nice to have an event, 
emitted once a day, signalling the taxi driver with the highest total amount of tips in that day
*/
from TaxiSecStr#window.timeBatch(24 hour)
select medallion, sum(tip_amount) as tips_total
group by medallion
order by tips_total DESC
insert into TodayDriversTips;

from TodayDriversTips#window.length(1)
select *
insert into PleasantDriverStr;

